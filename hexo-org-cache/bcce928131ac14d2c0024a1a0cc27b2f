{"md5":"b046c6c65f0bd1b1dda1e60fc5449fc5","content":"\n\n<script>\n  function editAtGithub(isRaw){\n    var url_parts = document.location.pathname.split('/');\n    var postname = url_parts[url_parts.length - 2];\n    if(url_parts.length == 3){ // is a page(wiki about etc)\n      postname = postname + '/index.org';\n    }else{\n      postname = '_posts/' + postname + '.org';\n    }\n    var url = 'https://github.com/cmal/learning_clojure/tree/source/source/' + postname;\n    if(isRaw)\n      url = 'https://raw.githubusercontent.com/cmal/learning_clojure/source/source/' + postname;\n    window.open(url);\n  }\n</script>\n<div id=\"outline-container-sec-1\" class=\"outline-2\">\n<h2 id=\"sec-1\">Differences</h2>\n<div class=\"outline-text-2\" id=\"text-1\">\n<p>\nThere are a few (as far as I know) differences between lambda functions (<code>fn</code>) and literal functions (<code>#(...)</code>):\n</p>\n\n<ol class=\"org-ol\">\n<li>By definition, literal functions are the reader form(or sugar) of Clojure compiler, but lambda functions are not.\n\n<p>\nSo <code>read-string</code> can be applied to literal functions.\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"list\">(<span class=\"keyword\">read-string</span> <span class=\"string\">&quot;#(inc %)&quot;</span>)</span></span><br><span class=\"line\"><span class=\"comment\">;; =&gt; (fn* [p1__37093#] (inc p1__37093#))</span></span><br></pre></td></tr></table></figure>\n</div>\n</li>\n\n<li><a href=\"../destructuring_assignment/#sec-1-3\">Last time</a> I say that <code>fn</code> implies a <code>do</code> in its body.\n\n<div class=\"org-src-container\">\n\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"list\">(<span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">fn</span></span> <span class=\"collection\">[x]</span></span><br><span class=\"line\">    <span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">prn</span></span> x)</span></span><br><span class=\"line\">    x)</span> <span class=\"number\">3</span>)</span></span><br></pre></td></tr></table></figure>\n</div>\n<p>\nbut literal functions must explicitly use <code>do</code> to wrap the two actions:\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"list\">(<span class=\"keyword\">#</span><span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">do</span></span> <span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">prn</span></span> %)</span></span><br><span class=\"line\">       %)</span> <span class=\"number\">3</span>)</span></span><br></pre></td></tr></table></figure>\n</div>\n</li>\n\n<li>Literal functions cannot explicitly do arity variadic:\n\n<p>\n<code>fn</code> can do this:\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">fn</span></span> <span class=\"collection\">[]</span></span><br><span class=\"line\">  <span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">do</span></span> sth1...)</span></span><br><span class=\"line\">  <span class=\"collection\">[x]</span></span><br><span class=\"line\">  <span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">do</span></span> sth2...)</span></span><br><span class=\"line\">  <span class=\"collection\">[x y]</span></span><br><span class=\"line\">  <span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">do</span></span> sth3...)</span></span><br><span class=\"line\">  <span class=\"collection\">[x y &amp; rest]</span></span><br><span class=\"line\">  <span class=\"list\">(<span class=\"keyword\"><span class=\"built_in\">do</span></span> sth4...)</span>)</span></span><br></pre></td></tr></table></figure>\n</div>\n<p>\nbut literal functions can not.\nHowever, literal functions can define a variadic function by using <code>%&amp;</code>:\n</p>\n<div class=\"org-src-container\">\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">#(- % (apply + %&amp;))</span><br><span class=\"line\">;; this is exactly like</span><br><span class=\"line\">(fn [x &amp; rest]</span><br><span class=\"line\">  (- x (apply + rest)))</span><br></pre></td></tr></table></figure>\n</div>\n</li>\n\n<li>Literal functions cannot be nested:\n\n<div class=\"org-src-container\">\n\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">;; You CANNOT do this:</span><br><span class=\"line\">#(#(inc %))</span><br><span class=\"line\">;; but you can use nest lambda functions:</span><br><span class=\"line\">(fn [x] (fn [y] (inc y)))</span><br></pre></td></tr></table></figure>\n</div>\n</li>\n</ol>\n</div>\n</div>\n\n<div style=\"font-size: 14px;padding: 5px;line-height: 20px;border: 1px solid;\"><a href=\"javascript: editAtGithub();\">Edit Me at Github</a> - <a href=\"javascript: editAtGithub(true)\">Org Source</a> - Last Updated 2016-11-06 &#x65E5; 23:20.<br>Render by <a href=\"https://github.com/CodeFalling/hexo-renderer-org\">hexo-renderer-org</a> with <a href=\"http://www.gnu.org/software/emacs/\">Emacs</a> 25.1.1 (<a href=\"http://orgmode.org\">Org</a> mode 8.2.10)</div>\n"}
